//Travis D.
//Arduino
//TouchPad Timer
//Fig


// Pin for the LED
//int LEDPin = 13;
// Pin to connect to your drawing
int capSensePin1 = 2;
int capSensePin2 = 3;
int capSensePin3 = 4;
int capSensePin4 = 5;
int capSensePin5 = 6;
int capSensePin6 = 7;
int capSensePin7 = 8;
int capSensePin8 = 9;

// This is how high the sensor needs to read in order
//  to trigger a touch.  You'll find this number
//  by trial and error, or you could take readings at 
//  the start of the program to dynamically calculate this.
int touchedCutoff = 60;
unsigned long start1, start2, start3, start4, start5, start6, start7, start8;
unsigned long finished1, finished2, finished3, finished4, finished5, finished6, finished7, finished8;
unsigned long elapsed;

void setup(){
  Serial.begin(9600);
  // Set up the LED
 /*
 pinMode(LEDPin, OUTPUT);
 digitalWrite(LEDPin, LOW);
 */
  pinMode(2, INPUT); // the start button
  pinMode(3, INPUT); // the stop button
  pinMode(4, INPUT);
  pinMode(5, INPUT);
  pinMode(6, INPUT);
  pinMode(7, INPUT);
  pinMode(8, INPUT);
  pinMode(9, INPUT);
 Serial.println("Press 1 for Start/reset, 2 for elapsed time");
}

void displayResult(unsigned long a, unsigned long b)
{
 float h, m, s, ms;
 unsigned long over;
 elapsed = a - b;
 h = int(elapsed / 3600000);
 over = elapsed % 3600000;
 m = int(over / 60000);
 over = over % 60000;
 s = int(over / 1000);
 ms = over % 1000;
 Serial.print("Raw elapsed time: ");
 Serial.println(elapsed);
 Serial.print("Elapsed time: ");
 Serial.print(h, 0);
 Serial.print("h ");
 Serial.print(m, 0);
 Serial.print("m ");
 Serial.print(s, 0);
 Serial.print("s ");
 Serial.print(ms, 0);
 Serial.println("ms");
 Serial.println(); 
}

void loop(){
  // If the capacitive sensor reads above a certain threshold,
  //  turn on the LED
  if (readCapacitivePin(capSensePin1) > touchedCutoff) {
   // digitalWrite(LEDPin, HIGH);

 start1 = millis();
 delay(200); // for debounce
 Serial.println("Pin 2 Started...");
 
   }
  else {
    //digitalWrite(LEDPin, LOW);
     finished1 = millis();
 delay(200); // for debounce 
 displayResult(finished1,start1);
  }
  
  if (readCapacitivePin(capSensePin2) > touchedCutoff) {
 start2 = millis();
 delay(200); // for debounce
 Serial.println("Pin 3 Started...");
 
   }
  else {
    //digitalWrite(LEDPin, LOW);
     finished2 = millis();
 delay(200); // for debounce 
 displayResult(finished2,start2);
  }
  
 if (readCapacitivePin(capSensePin3) > touchedCutoff) {
 start3 = millis();
 delay(200); // for debounce
 Serial.println("Pin 4 Started...");
 
   }
  else {
    //digitalWrite(LEDPin, LOW);
     finished3 = millis();
 delay(200); // for debounce 
 displayResult(finished3,start3);
  } 
  
 if (readCapacitivePin(capSensePin4) > touchedCutoff) {
   start4 = millis();
 delay(200); // for debounce
 Serial.println("Pin 5 Started...");
 
   }
  else {
    //digitalWrite(LEDPin, LOW);
     finished4 = millis();
 delay(200); // for debounce 
 displayResult(finished4,start4);
  }
 
 if (readCapacitivePin(capSensePin5) > touchedCutoff) {
   start5 = millis();
 delay(200); // for debounce
 Serial.println("Pin 6 Started...");
 
   }
  else {
    //digitalWrite(LEDPin, LOW);
     finished5 = millis();
 delay(200); // for debounce 
 displayResult(finished5,start5);
  }
  
  if (readCapacitivePin(capSensePin6) > touchedCutoff) {
   start6 = millis();
 delay(200); // for debounce
 Serial.println("Pin 7 Started...");
   }
  else {
    //digitalWrite(LEDPin, LOW);
     finished6 = millis();
 delay(200); // for debounce 
 displayResult(finished6,start6);
  }
  
 if (readCapacitivePin(capSensePin7) > touchedCutoff) {
 start7 = millis();
 delay(200); // for debounce
 Serial.println("Pin 8 Started...");
 
   }
  else {
    //digitalWrite(LEDPin, LOW);
     finished7 = millis();
 delay(200); // for debounce 
 displayResult(finished7,start7);
  }
     
 if (readCapacitivePin(capSensePin8) > touchedCutoff) {
 start8 = millis();
 delay(200); // for debounce
 Serial.println("Pin 9 Started...");
 
   }
  else {
    //digitalWrite(LEDPin, LOW);
     finished8 = millis();
 delay(200); // for debounce 
 displayResult(finished8,start8);
  }
  
 
  /*
  // Every 500 ms, print the value of the capacitive sensor
  if ( (millis() % 500) == 0){//half a second increments
    Serial.print("pin2:  ");
    Serial.print(readCapacitivePin(capSensePin1));
    Serial.print("\n");
    Serial.print("pin3:  ");
    Serial.println(readCapacitivePin(capSensePin2));  
    Serial.print("\n");
    Serial.print("pin4:  ");
    Serial.println(readCapacitivePin(capSensePin3));  
    Serial.print("\n");
    Serial.print("pin5:  ");
    Serial.println(readCapacitivePin(capSensePin4));  
    Serial.print("\n");
    Serial.print("pin6:  ");
    Serial.println(readCapacitivePin(capSensePin5));  
    Serial.print("\n");
    Serial.print("pin7:  ");
    Serial.println(readCapacitivePin(capSensePin6));  
    Serial.print("\n");
    Serial.print("pin8:  ");
    Serial.println(readCapacitivePin(capSensePin7));  
    Serial.print("\n");
    Serial.print("pin9:  ");
    Serial.println(readCapacitivePin(capSensePin8));  
        
 }
*/
}

// readCapacitivePin
//  Input: Arduino pin number
//  Output: A number, from 0 to 17 expressing
//          how much capacitance is on the pin
//  When you touch the pin, or whatever you have
//  attached to it, the number will get higher
//  In order for this to work now,
// The pin should have a 1+Megaohm resistor pulling
//  it up to +5v.
uint8_t readCapacitivePin(int pinToMeasure){
  // This is how you declare a variable which
  //  will hold the PORT, PIN, and DDR registers
  //  on an AVR
  volatile uint8_t* port;
  volatile uint8_t* ddr;
  volatile uint8_t* pin;
  // Here we translate the input pin number from
  //  Arduino pin number to the AVR PORT, PIN, DDR,
  //  and which bit of those registers we care about.
  byte bitmask;
  if ((pinToMeasure >= 0) && (pinToMeasure <= 7)){
    port = &PORTD;
    ddr = &DDRD;
    bitmask = 1 << pinToMeasure;
    pin = &PIND;
  }
  if ((pinToMeasure > 7) && (pinToMeasure <= 13)){
    port = &PORTB;
    ddr = &DDRB;
    bitmask = 1 << (pinToMeasure - 8);
    pin = &PINB;
  }
  if ((pinToMeasure > 13) && (pinToMeasure <= 19)){
    port = &PORTC;
    ddr = &DDRC;
    bitmask = 1 << (pinToMeasure - 13);
    pin = &PINC;
  }
  // Discharge the pin first by setting it low and output
  *port &= ~(bitmask);
  *ddr  |= bitmask;
  delay(1);
  // Make the pin an input WITHOUT the internal pull-up on
  *ddr &= ~(bitmask);
  // Now see how long the pin to get pulled up
  int cycles = 16000;
  for(int i = 0; i < cycles; i++){
    if (*pin & bitmask){
      cycles = i;
      break;
    }
  }
  // Discharge the pin again by setting it low and output
  //  It's important to leave the pins low if you want to 
  //  be able to touch more than 1 sensor at a time - if
  //  the sensor is left pulled high, when you touch
  //  two sensors, your body will transfer the charge between
  //  sensors.
  *port &= ~(bitmask);
  *ddr  |= bitmask;
  
  return cycles;
}


/*

// Project 31 â€“ Creating a Stopwatch
unsigned long start, finished, elapsed;
void setup() 
{
 Serial.begin(9600); 
 pinMode(2, INPUT); // the start button
 pinMode(3, INPUT); // the stop button
 Serial.println("Press 1 for Start/reset, 2 for elapsed time");
}
void displayResult()
{
 float h, m, s, ms;
 unsigned long over;
elapsed = finished - start;
 h = int(elapsed / 3600000);
 over = elapsed % 3600000;
 m = int(over / 60000);
 over = over % 60000;
 s = int(over / 1000);
 ms = over % 1000;
 Serial.print("Raw elapsed time: ");
 Serial.println(elapsed);
 Serial.print("Elapsed time: ");
 Serial.print(h, 0);
 Serial.print("h ");
 Serial.print(m, 0);
 Serial.print("m ");
 Serial.print(s, 0);
 Serial.print("s ");
 Serial.print(ms, 0);
 Serial.println("ms");
 Serial.println(); 
}
void loop() 
{
 if (digitalRead(2) == HIGH)
 {
 start = millis();
 delay(200); // for debounce
 Serial.println("Started...");
 }

if (digitalRead(3) == HIGH)
 {
 finished = millis();
 delay(200); // for debounce 
 displayResult();
 }
}

*/
